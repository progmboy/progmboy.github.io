<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WaaSMedicAgent Elevation Of Privilege | progmboy</title>
<link rel="shortcut icon" href="https://progmboy.github.io/favicon.ico?v=1604380659094">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://progmboy.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://progmboy.github.io">
  <img class="avatar" src="https://progmboy.github.io/images/avatar.png?v=1604380659094" alt="">
  </a>
  <h1 class="site-title">
    progmboy
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              WaaSMedicAgent Elevation Of Privilege
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2020-11-03 ·
              </time>
              
                <a href="https://progmboy.github.io/tag/XxUr2fZu1/" class="post-tag">
                  # vul
                </a>
              
            </div>
            
            <div class="post-content">
              <p>[TOC]</p>
<h2 id="environment">Environment</h2>
<p>Windows 10 x64 1903 (Of course, the same problem exists in the inside preview)</p>
<h2 id="root-cause">Root Cause</h2>
<p>We can use RPC calls to make WaaSMedicSvc lunch WaaSMedicAgent.exe process.<br>
For example, you can use the following command</p>
<pre><code>$WaaS = New-Object -ComObject &quot;Microsoft.WaaSMedic.1&quot;
$Plugins = $WaaS.LaunchDetectionOnly(&quot;Troubleshooter&quot;)
</code></pre>
<p>If you are runing procmon.exe you will see WaaSMedicAgent.exe started by WaaSMedicSvc service.<br>
The Command line of WaaSMedicAgent.exe looked like this:</p>
<pre><code>C:\WINDOWS\System32\WaaSMedicAgent.exe {98024FEF-B13F-4DB7-A4F2-803836A88D3D} PoSxsX/5D0CfZh4+.0.0
</code></pre>
<p>The logic flow is roughly as follows:</p>
<pre><code>WaaSMedicSvc!WaasMedic::CWaasRemediation::RunEx
WaaSMedicSvc!WaasMedic::CWaasRemediation::RunPluginsInCapsule
WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::CreateSandbox
WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::ConnectToSandbox
WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::SandboxLoadLibrary
</code></pre>
<p>Let's look at the first parameter of the process WaaSMedicAgent.exe process, which is a UUID.<br>
The logic generated by this UUID is in WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::Init</p>
<pre><code class="language-c">__int64 __fastcall WaasMedic::CSandboxRpcWrapper::Init(WaasMedic::CSandboxRpcWrapper *this, struct #284 *a2)
{
  HRESULT v3; // eax
  unsigned int v4; // ebx
  const unsigned __int16 *v5; // rdx
  GUID pguid; // [rsp+20h] [rbp-28h]

  this-&gt;field_20 = (__int64)a2;
  v3 = CoCreateGuid(&amp;pguid);
  v4 = v3;
  if ( v3 &lt; 0 )
  {
    v5 = L&quot;Failed to create a GUID for RPC endpoint. hr = 0x%08x.&quot;;
LABEL_9:
    LogLevelW(2u, v5, (unsigned int)v3);
    return v4;
  }
  if ( this-&gt;EndPoint )
  {
    CoTaskMemFree((LPVOID)this-&gt;EndPoint);
    this-&gt;EndPoint = 0i64;
  }
  v3 = StringFromCLSID(&amp;pguid, (LPOLESTR *)this);
  v4 = v3;
  if ( v3 &lt; 0 )
  {
    v5 = L&quot;Failed to convert GUID to string for RPC endpoint. hr = 0x%08x.&quot;;
    goto LABEL_9;
  }
  LogLevelW(4u, L&quot;RPC Endpoint: %s&quot;, this-&gt;EndPoint);
  v3 = WaasMedic::CSandboxRpcWrapper::PrepareCommandLine(this);
  v4 = v3;
  if ( v3 &lt; 0 )
  {
    v5 = L&quot;Failed to prepare command line for WaaSMedicAgent. hr = 0x%08x.&quot;;
    goto LABEL_9;
  }
  return v4;
}
</code></pre>
<p>The UUID is created by <code>CoCreateGuid</code> and is a random value. And This random value is difficult to predict.</p>
<p>The logic for creating the WaaSMedicAgent.exe process is in WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::CreateSandbox. Use the UUID created above as the first parameter.<br>
Finally, the WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::ConnectToSandbox function is used to connect RPC Server using the UUID as the Endpoint Name.</p>
<p>So here we can guess that the logic of CSandboxRpcWrapper is to create a random UUID, lunch the WaaSMedicAgent with this UUID as a parameter, and then the WaaSMedicAgent process uses the UUID as the Endpoint Name to create the RPC Service. Then CSandboxRpcWrapper connects RPC Server with the UUID. Because the UUID is a randomly value, So In this way can ensure that other processes can't guess the Endpoint name and can't connect to this RPC server.</p>
<p>Let's take a look at the logic of WaaSMedicSvc!WaasMedic::CSandboxRpcWrapper::CreateSandbox:</p>
<pre><code class="language-c">__int64 __fastcall WaasMedic::CSandboxRpcWrapper::CreateSandbox(WaasMedic::CSandboxRpcWrapper *this)
{

  ....
  
  //
  // Create  mutex use UUID as name
  //
  
  this-&gt;hMutex = CreateMutexW(0i64, 1, (LPCWSTR)this-&gt;EndPoint);
  if ( (unsigned __int64)(his-&gt;hMutex - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
    CloseHandle(v10);
  this-&gt;hMutex = v11;
  
  
  LogLevelW(4u, L&quot;Creating Process: %s&quot;, &amp;Dst);
  if ( !CreateProcessW(0i64, &amp;Dst, 0i64, 0i64, 0, 0x8000000u, 0i64, 0i64, &amp;StartupInfo, &amp;ProcessInformation) )
  ...
}

</code></pre>
<p>We can see that a new mutex is created in WaasMedic::CSandboxRpcWrapper::CreateSandbox and the UUID is used as the name.<br>
So the problem is coming. We can enumerate all the mutex through NtOpenDirectoryObject. So we can connect the RPC service created by CSandboxRpcWrapper in other processes.</p>
<p>Next we look at <code>WaaSMedicAgent.exe</code><br>
This process will create an RPC Server. The RPC SecurityCallback function is also very interesting:</p>
<pre><code class="language-c">__int64 __fastcall AgentSecurityCallback(RPC_IF_HANDLE InterfaceUuid, void *Context)
{
  int v2; // eax
  char v4; // [rsp+40h] [rbp+18h]

  v4 = 0;
  v2 = WaasMedic::IsCallerLocalSystem((#73 *)&amp;v4, (bool *)Context);
  if ( !v4 || v2 &lt; 0 )
    LogLevelW(2u, L&quot;Agent: IsCallerLocalSystem failed! hr = 0x%08x&quot;, (unsigned int)v2);
  
  //
  // Allways return success
  //
  return 0i64;
}
</code></pre>
<p>The AgentSecurityCallback function will check if the caller comes from the LocalSystem. But If it is not it does not return an error. So here we can make an RPC connection from a Medium privilege process.</p>
<p>The interface of the RPC service created by WaaSMedicAgent is as follows:</p>
<pre><code class="language-idl">[
	uuid(b35534c5-a66e-473f-afa3-a4b21c02ea27),
	version(1.0),
]
interface WaaSMedicAgentIfName
{
	HRESULT PluginAction(
		[in]handle_t hbinding, 
		[in][string]wchar_t* p0, 
		[in][string]wchar_t* p1, 
		[out]small* p2);

	HRESULT LoadPluginLibrary(
		[in]handle_t hbinding,
		[in][string] wchar_t* p0);
	HRESULT FreePluginLibrary();
	void Shutdown();
}
</code></pre>
<p>What we care about is WaaSMedicAgent!LoadPluginLibrary:</p>
<pre><code class="language-c">__int64 __fastcall LoadPluginLibrary(__int64 a1, const WCHAR *LibraryPath)
{
  v3 = ExpandEnvironmentStringsW(LibraryPath, &amp;szLibraryPath, 0x104u);
  if ( !v3 )
  {
    v4 = GetLastError();
    v5 = L&quot;Could not expand the string (%s) to find the actual requested library name on disk.&quot;;
    v6 = (unsigned __int16)v4 | 0x80070000;
    if ( v4 &lt;= 0 )
      v6 = v4;
    goto LABEL_4;
  }
  if ( v3 &gt; 0x104 )
  {
    v6 = -2147024774;
    v5 = L&quot;Could not expand the string(%s) due to insufficient buffer&quot;;
LABEL_4:
    LogLevelW(2u, v5, v2);
    return v6;
  }
  
  v8 = (char *)CreateFileW(&amp;szLibraryPath, 0x80000000, 1u, 0i64, 3u, 0x80u, 0i64);
  

  v6 = WaasMedic::IsTrustedLibrary(&amp;szLibraryPath, v7);
  if ( (v6 &amp; 0x80000000) == 0 )
  {
    g_hPluginCollection = LoadLibraryW(&amp;szLibraryPath);
    if ( g_hPluginCollection )
    {
      v11 = WaasMedic::SafeAllocString((#73 *)&amp;Dst, (const unsigned __int16 *)&amp;g_pszCapsuleName, v10);
      }
  }
  
  
  LABEL_36:
  if ( (unsigned __int64)(v8 - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
    CloseHandle(v8);
}
</code></pre>
<p>Here we can see that the file handle is opened first by using CreateFile, and then the signature verification is performed. After the signature verification is successful, the LoadLibrary is executed, and finally the CloseHandle is performed. This is a good way to prevent TOCTOU.</p>
<p>But a more serious problem is the LoadLibrary function. If we pass in a path that is not the end of <code>.dll</code>, the Loadlibrary function will automatically add the .dll and then load it. So here it is obvious. We are looking for a signed dll file. Name it <code>testdll</code> and use our own dll named <code>testdll.dll</code> and then call the RPC function LoadPluginLibrary. This bypasses the signature check.</p>
<p><em>So to sum up, the entire EOP has three problem points:</em></p>
<ol>
<li>CSandboxRpcWrapper in WaaSMedicSvc.dll uses CreateMutex to leak the Endpoint Name.</li>
<li>The SecurityCallback of WaaSMedicAgent.exe does not correctly check the caller.</li>
<li>LoadLibrary did not check if the path was the end of the <code>.dll</code>.</li>
</ol>
<h2 id="exploit">Exploit</h2>
<ol>
<li>find a signed dll named to <code>testdll</code> and our dll named to <code>testdll.dll</code></li>
<li>Create a new thread to monitor the creation of Mutex object.</li>
<li>Create <code>Microsoft.WaaSMedic.1</code> Instance and call the <code>LaunchDetectionOnly</code> function.</li>
<li>A new mutex object will be created, the Monitor thread will capture this behavior, and connect to the Rpc Server with the name of the mutex object.</li>
<li>call <code>LoadPluginLibrary</code> with the path of <code>testdll</code> as parameter.</li>
</ol>
<h2 id="reproduction">Reproduction</h2>
<p>I provide a poc for this vulnerability, the poc include a dll that to lunch <code>cmd</code>, named <code>testdll.dll</code> And a signed dll copy from windows.</p>
<ol>
<li>run <code>poc_waasmedic.exe</code> with normal user.</li>
<li>you will see a cmd which running under System privileges.</li>
</ol>

            </div>
          </article>
        </div>

        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'a89ffe4b4a11d9839fe5',
    clientSecret: '4c5f5e9447262d1a729b3eac09ab488b0c81304c ',
    repo: 'progmboy.github.io',
    owner: '',
    admin: [''],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
   | 
  <a class="rss" href="https://progmboy.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
